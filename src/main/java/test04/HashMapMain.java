package test04;

import java.util.HashMap;
import java.util.Hashtable;

public class HashMapMain {
    public static void main(String[] args) {

        System.out.println("aaaaa");

        HashMap<String, Object> map = new HashMap<>();

        map.put("name", "zhangsan");
        /**
         * 底层实现：数组+链表实现
         * jdk8开始链表高度到8，数组长度到64，链表转变为红黑树，元素以内部类Node节点存在
         * 计算key的hash值，二次hash然后对数组长度取模，对应到数组下标。
         * 如果没有生产hash冲突（下标位置没有元素），则直接创建Node存入数组，
         * 如果产生hash冲突，先进行equal比较，相同则取代该元素，不同，则判断链表高度插入链表，链表高度达到8，并且数组长度到64
         * 则转为红黑树，长度低于6则将红黑树转回链表。
         */

        /**
         * 红黑树除了遵循基本的BST规则外，还需遵循以下4个规则：
         * 每一个节点不是红色就是黑色；
         * 根节点一定是黑色的；
         * 如果节点时红色的，那么它的子节点必须都是黑色的；
         * 从根节点到叶子节点或空子节点的每条路径，必须包含相同数目的黑色节点。
         */

        /**
         *
         * 1.7版本
         * 1. 先⽣成新数组
         * 2. 遍历⽼数组中的每个位置上的链表上的每个元素
         * 3. 取每个元素的key，并基于新数组⻓度，计算出每个元素在新数组中的下标
         * 4. 将元素添加到新数组中去
         * 5. 所有元素转移完了之后，将新数组赋值给HashMap对象的table属性
         *
         * 1.8版本
         * 1. 先⽣成新数组
         * 2. 遍历⽼数组中的每个位置上的链表或红⿊树
         * 3. 如果是链表，则直接将链表中的每个元素重新计算下标，并添加到新数组中去
         * 4. 如果是红⿊树，则先遍历红⿊树，先计算出红⿊树中每个元素对应在新数组中的下标位置
         *      a. 统计每个下标位置的元素个数
         *      b. 如果该位置下的元素个数超过了8，则⽣成⼀个新的红⿊树，并将根节点的添加到新数组的对应位置
         *      c. 如果该位置下的元素个数没有超过8，那么则⽣成⼀个链表，并将链表的头节点添加到新数组的对应位置
         * 5. 所有元素转移完了之后，将新数组赋值给HashMap对象的table属性
         */

        /**
         * 先说HashMap的Put⽅法的⼤体流程：
         * 1. 根据Key通过哈希算法与与运算得出数组下标
         * 2. 如果数组下标位置元素为空，则将key和value封装为Entry对象（JDK1.7中是Entry对象，JDK1.8中是 Node对象）并放⼊该位置
         * 3. 如果数组下标位置元素不为空，则要分情况讨论
         * a. 如果是JDK1.7，则先判断是否需要扩容，如果要扩容就进⾏扩容，如果不⽤扩容就⽣成Entry对 象，并使⽤头插法添加到当前位置的链表中
         * b. 如果是JDK1.8，则会先判断当前位置上的Node的类型，看是红⿊树Node，还是链表Node
         *      i. 如果是红⿊树Node，则将key和value封装为⼀个红⿊树节点并添加到红⿊树中去，在这个过 程中会判断红⿊树中是否存在当前key，如果存在则更新value
         *      ii. 如果此位置上的Node对象是链表节点，则将key和value封装为⼀个链表Node并通过尾插法插⼊到链表的最后位置去，
         *          因为是尾插法，所以需要遍历链表，在遍历链表的过程中会判断是否3存在当前key，
         *          如果存在则更新value，当遍历完链表后，将新链表Node插⼊到链表中，插⼊ 到链表后，会看当前链表的节点个数，
         *          如果⼤于等于8，那么则会将该链表转成红⿊树
         *      iii. 将key和value封装为Node插⼊到链表或红⿊树中后，再判断是否需要进⾏扩容，如果需要就 扩容，如果不需要就结束PUT⽅法
         */


        /**
         * 1. HashMap方法没有synchronized修饰，线程非安全，HashTabel线程安全
         * 2. HashMap允许key和value为null,而HashTabel不允许。
         */
        Hashtable hashtable = new Hashtable();

        hashtable.put("aaa", 23);



    }
}
